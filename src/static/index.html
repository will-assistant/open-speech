<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Open Speech</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
<style>
/* ‚îÄ‚îÄ Theme Variables ‚îÄ‚îÄ */
:root {
  --bg: #fafafa; --surface: #ffffff; --elevated: #f4f4f5;
  --text: #18181b; --text2: #71717a;
  --accent: #6366f1; --accent-hover: #4f46e5; --success: #22c55e; --error: #ef4444;
  --border: #e4e4e7;
  --shadow: 0 1px 3px rgba(0,0,0,0.08), 0 1px 2px rgba(0,0,0,0.04);
  --radius: 12px; --radius-sm: 8px;
}
[data-theme="dark"] {
  --bg: #0f0f12; --surface: #1a1a22; --elevated: #24242e;
  --text: #e8e8ed; --text2: #8888a0;
  --border: #2a2a38;
  --shadow: 0 1px 3px rgba(0,0,0,0.3);
}

/* ‚îÄ‚îÄ Reset & Base ‚îÄ‚îÄ */
*, *::before, *::after { margin: 0; padding: 0; box-sizing: border-box; }
body {
  font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
  background: var(--bg); color: var(--text); min-height: 100vh;
  transition: background 0.3s, color 0.3s;
  font-size: 14px; line-height: 1.5;
}
.container { max-width: 960px; margin: 0 auto; padding: 24px; }

/* ‚îÄ‚îÄ Header ‚îÄ‚îÄ */
.header {
  display: flex; align-items: center; justify-content: space-between;
  padding-bottom: 16px; margin-bottom: 24px;
  border-bottom: 1px solid var(--border);
}
.header-left { display: flex; align-items: center; gap: 12px; }
.wordmark { font-size: 1.35rem; font-weight: 600; letter-spacing: -0.02em; }
.version-badge {
  font-size: 0.7rem; font-weight: 500; padding: 2px 8px;
  background: var(--elevated); border: 1px solid var(--border);
  border-radius: 20px; color: var(--text2);
}
.theme-toggle {
  background: var(--elevated); border: 1px solid var(--border); border-radius: var(--radius-sm);
  width: 40px; height: 40px; cursor: pointer; display: flex; align-items: center; justify-content: center;
  font-size: 1.1rem; transition: background 0.2s, border-color 0.2s; color: var(--text2);
}
.theme-toggle:hover { border-color: var(--accent); color: var(--text); }

/* ‚îÄ‚îÄ Tabs ‚îÄ‚îÄ */
.tabs { display: flex; gap: 4px; margin-bottom: 24px; background: var(--elevated); padding: 4px; border-radius: var(--radius); }
.tab {
  flex: 1; text-align: center; padding: 10px 20px; border-radius: var(--radius-sm);
  cursor: pointer; font-weight: 500; font-size: 0.9rem; color: var(--text2);
  transition: all 0.2s; user-select: none;
}
.tab:hover { color: var(--text); }
.tab.active { background: var(--accent); color: #fff; box-shadow: 0 1px 3px rgba(99,102,241,0.3); }
.panel { display: none; animation: fadeIn 0.25s ease; }
.panel.active { display: block; }
@keyframes fadeIn { from { opacity: 0; transform: translateY(4px); } to { opacity: 1; transform: translateY(0); } }

/* ‚îÄ‚îÄ Cards ‚îÄ‚îÄ */
.card {
  background: var(--surface); border: 1px solid var(--border); border-radius: var(--radius);
  padding: 24px; margin-bottom: 16px; transition: background 0.3s, border-color 0.3s;
}
[data-theme="light"] .card { box-shadow: var(--shadow); border-color: transparent; }
.card-title { font-size: 0.8rem; font-weight: 600; text-transform: uppercase; letter-spacing: 0.05em; color: var(--text2); margin-bottom: 16px; }

/* ‚îÄ‚îÄ Form Elements ‚îÄ‚îÄ */
label { display: block; font-size: 0.8rem; font-weight: 500; color: var(--text2); margin-bottom: 6px; }
select, input[type=text], textarea {
  background: var(--elevated); color: var(--text); border: 1px solid var(--border);
  border-radius: var(--radius-sm); padding: 10px 12px; width: 100%; font-size: 0.875rem;
  font-family: inherit; transition: border-color 0.2s;
}
select:focus, input:focus, textarea:focus { outline: none; border-color: var(--accent); box-shadow: 0 0 0 3px rgba(99,102,241,0.15); }
textarea { resize: vertical; min-height: 120px; }
.row { display: flex; gap: 16px; align-items: start; }
.row > * { flex: 1; }
.form-group { margin-bottom: 16px; }

/* ‚îÄ‚îÄ Segmented Control ‚îÄ‚îÄ */
.segmented { display: inline-flex; background: var(--elevated); border-radius: var(--radius-sm); padding: 3px; border: 1px solid var(--border); }
.seg-opt { padding: 6px 14px; font-size: 0.8rem; cursor: pointer; border-radius: 6px; font-weight: 500; color: var(--text2); transition: all 0.2s; white-space: nowrap; }
.seg-opt:hover { color: var(--text); }
.seg-opt.active { background: var(--accent); color: #fff; }

/* ‚îÄ‚îÄ Buttons ‚îÄ‚îÄ */
.btn {
  display: inline-flex; align-items: center; gap: 8px;
  background: var(--accent); color: #fff; border: none; border-radius: var(--radius-sm);
  padding: 10px 20px; cursor: pointer; font-size: 0.875rem; font-weight: 500;
  font-family: inherit; transition: all 0.2s;
}
.btn:hover { background: var(--accent-hover); }
.btn:disabled { opacity: 0.4; cursor: not-allowed; }
.btn:focus-visible { outline: 2px solid var(--accent); outline-offset: 2px; }
.btn-ghost { background: transparent; color: var(--text2); border: 1px solid var(--border); }
.btn-ghost:hover { background: var(--elevated); color: var(--text); border-color: var(--text2); }
.btn-danger { background: var(--error); }
.btn-danger:hover { background: #dc2626; }
.btn-success { background: var(--success); color: #fff; }
.btn-success:hover { background: #16a34a; }
.btn-sm { padding: 6px 14px; font-size: 0.8rem; }
.btn .spinner { display: none; width: 16px; height: 16px; border: 2px solid rgba(255,255,255,0.3); border-top-color: #fff; border-radius: 50%; animation: spin 0.6s linear infinite; }
.btn.loading .spinner { display: block; }
@keyframes spin { to { transform: rotate(360deg); } }

/* ‚îÄ‚îÄ Drop Zone ‚îÄ‚îÄ */
.dropzone {
  border: 2px dashed var(--border); border-radius: var(--radius); padding: 32px;
  text-align: center; color: var(--text2); cursor: pointer; transition: all 0.2s;
}
.dropzone:hover, .dropzone.dragover { border-color: var(--accent); color: var(--accent); background: rgba(99,102,241,0.04); }
.dropzone input { display: none; }
.dropzone-icon { font-size: 1.5rem; margin-bottom: 8px; display: block; }
.dropzone-label { font-size: 0.875rem; font-weight: 500; }
.dropzone-hint { font-size: 0.75rem; color: var(--text2); margin-top: 6px; }

/* ‚îÄ‚îÄ Results ‚îÄ‚îÄ */
.result-area {
  background: var(--elevated); border: 1px solid var(--border); border-radius: var(--radius-sm);
  padding: 16px; min-height: 80px; white-space: pre-wrap; max-height: 400px; overflow-y: auto;
  font-family: 'SF Mono', 'Fira Code', 'Cascadia Code', monospace; font-size: 0.825rem; line-height: 1.6;
  color: var(--text); transition: background 0.3s;
}
.result-area .partial { color: var(--text2); }
.result-placeholder { color: var(--text2); font-family: inherit; font-style: italic; }

/* ‚îÄ‚îÄ WS Status ‚îÄ‚îÄ */
.ws-status { display: inline-flex; align-items: center; gap: 6px; font-size: 0.8rem; color: var(--text2); }
.ws-dot { width: 8px; height: 8px; border-radius: 50%; background: var(--error); flex-shrink: 0; transition: background 0.3s; }
.ws-dot.connected { background: var(--success); }
.ws-dot.connecting { background: #eab308; animation: pulse-dot 1.5s infinite; }
@keyframes pulse-dot { 0%,100% { opacity: 1; } 50% { opacity: 0.4; } }

/* ‚îÄ‚îÄ Mic Button ‚îÄ‚îÄ */
.mic-btn {
  width: 48px; height: 48px; min-width: 48px; border-radius: 50%; border: 2px solid var(--border);
  background: var(--surface); cursor: pointer; font-size: 1.2rem; transition: all 0.2s;
  display: flex; align-items: center; justify-content: center; color: var(--text);
}
.mic-btn:hover { border-color: var(--accent); }
.mic-btn.recording { background: var(--accent); border-color: var(--accent); color: #fff; animation: pulse-mic 1.5s infinite; }
.mic-btn.speech { background: var(--error); border-color: var(--error); color: #fff; animation: pulse-speech 0.8s infinite; }
@keyframes pulse-mic { 0%,100% { box-shadow: 0 0 0 0 rgba(99,102,241,0.4); } 50% { box-shadow: 0 0 0 12px rgba(99,102,241,0); } }
@keyframes pulse-speech { 0%,100% { box-shadow: 0 0 0 0 rgba(239,68,68,0.5); } 50% { box-shadow: 0 0 0 14px rgba(239,68,68,0); } }
.vad-indicator { display: inline-block; width: 8px; height: 8px; border-radius: 50%; margin-right: 6px; vertical-align: middle; }
.vad-indicator.idle { background: var(--text2); }
.vad-indicator.listening { background: var(--accent); }
.vad-indicator.speech { background: var(--error); animation: pulse-dot 0.6s infinite; }
.vad-indicator.processing { background: #eab308; animation: pulse-dot 1s infinite; }

/* ‚îÄ‚îÄ Switch ‚îÄ‚îÄ */
.switch-wrap { display: flex; align-items: center; gap: 8px; }
.switch { position: relative; width: 44px; height: 24px; flex-shrink: 0; }
.switch input { opacity: 0; width: 0; height: 0; }
.switch-track {
  position: absolute; inset: 0; background: var(--border); border-radius: 12px;
  cursor: pointer; transition: background 0.2s;
}
.switch-track::after {
  content: ''; position: absolute; top: 3px; left: 3px; width: 18px; height: 18px;
  background: #fff; border-radius: 50%; transition: transform 0.2s;
}
.switch input:checked + .switch-track { background: var(--accent); }
.switch input:checked + .switch-track::after { transform: translateX(20px); }

/* ‚îÄ‚îÄ Range Slider ‚îÄ‚îÄ */
input[type=range] {
  -webkit-appearance: none; width: 100%; height: 6px; background: var(--border);
  border-radius: 3px; outline: none;
}
input[type=range]::-webkit-slider-thumb {
  -webkit-appearance: none; width: 20px; height: 20px; background: var(--accent);
  border-radius: 50%; cursor: pointer; border: 3px solid var(--surface);
  box-shadow: 0 1px 3px rgba(0,0,0,0.2);
}

/* ‚îÄ‚îÄ Audio Player ‚îÄ‚îÄ */
.audio-player {
  display: none; background: var(--elevated); border: 1px solid var(--border);
  border-radius: var(--radius-sm); padding: 12px 16px; margin-top: 16px;
  align-items: center; gap: 12px;
}
.audio-player.visible { display: flex; }
.play-btn {
  width: 40px; height: 40px; min-width: 40px; border-radius: 50%; border: none;
  background: var(--accent); color: #fff; cursor: pointer; font-size: 1rem;
  display: flex; align-items: center; justify-content: center; transition: background 0.2s;
}
.play-btn:hover { background: var(--accent-hover); }
.audio-progress { flex: 1; display: flex; flex-direction: column; gap: 4px; }
.progress-bar { width: 100%; height: 4px; background: var(--border); border-radius: 2px; cursor: pointer; position: relative; }
.progress-fill { height: 100%; background: var(--accent); border-radius: 2px; width: 0; transition: width 0.1s; }
.audio-time { font-size: 0.75rem; color: var(--text2); font-variant-numeric: tabular-nums; }

/* ‚îÄ‚îÄ Models Table ‚îÄ‚îÄ */
.models-table { width: 100%; border-collapse: collapse; font-size: 0.85rem; }
.models-table th { padding: 10px 12px; text-align: left; font-weight: 600; font-size: 0.75rem; text-transform: uppercase; letter-spacing: 0.05em; color: var(--text2); border-bottom: 2px solid var(--border); }
.models-table td { padding: 12px; border-bottom: 1px solid var(--border); vertical-align: middle; }
.models-table tr:last-child td { border-bottom: none; }
.models-table tr:hover td { background: var(--elevated); }
.badge { display: inline-block; padding: 3px 10px; border-radius: 20px; font-size: 0.7rem; font-weight: 600; letter-spacing: 0.02em; }
.badge-loaded { background: rgba(34,197,94,0.15); color: var(--success); }
.badge-unloaded { background: var(--elevated); color: var(--text2); border: 1px solid var(--border); }
.badge-stt { background: rgba(99,102,241,0.12); color: var(--accent); }
.badge-tts { background: rgba(234,179,8,0.12); color: #ca8a04; }
.models-header { display: flex; align-items: center; justify-content: space-between; margin-bottom: 16px; }
.models-count { font-size: 0.85rem; color: var(--text2); }
.refresh-icon { display: inline-block; font-size: 0.85rem; color: var(--text2); }
.refresh-icon.spinning { animation: spin 1s linear infinite; }

/* ‚îÄ‚îÄ History ‚îÄ‚îÄ */
.history { margin-top: 24px; }
.history-toggle {
  display: flex; align-items: center; gap: 8px; cursor: pointer; color: var(--text2);
  font-size: 0.85rem; font-weight: 500; padding: 8px 0; user-select: none;
}
.history-toggle:hover { color: var(--text); }
.history-toggle .arrow { transition: transform 0.2s; font-size: 0.7rem; }
.history-toggle .arrow.open { transform: rotate(90deg); }
.history-items { display: none; }
.history-items.open { display: block; }
.history-item {
  background: var(--elevated); border: 1px solid var(--border); border-radius: var(--radius-sm);
  padding: 12px; margin-top: 8px; font-size: 0.825rem; cursor: pointer; transition: border-color 0.2s;
}
.history-item:hover { border-color: var(--accent); }
.history-item .preview { margin-bottom: 4px; }
.history-item .meta { color: var(--text2); font-size: 0.75rem; }

/* ‚îÄ‚îÄ Toast ‚îÄ‚îÄ */
.toast-container { position: fixed; bottom: 24px; right: 24px; z-index: 1000; display: flex; flex-direction: column; gap: 8px; }
.toast {
  background: var(--surface); border: 1px solid var(--border); border-radius: var(--radius-sm);
  padding: 12px 20px; font-size: 0.85rem; box-shadow: 0 4px 12px rgba(0,0,0,0.15);
  display: flex; align-items: center; gap: 10px;
  animation: toastIn 0.3s ease; min-width: 280px;
}
.toast.removing { animation: toastOut 0.3s ease forwards; }
.toast-success .toast-dot { background: var(--success); }
.toast-error .toast-dot { background: var(--error); }
.toast-dot { width: 8px; height: 8px; border-radius: 50%; flex-shrink: 0; }
@keyframes toastIn { from { opacity: 0; transform: translateY(12px); } }
@keyframes toastOut { to { opacity: 0; transform: translateY(12px); } }

/* ‚îÄ‚îÄ Char count ‚îÄ‚îÄ */
.char-count { text-align: right; font-size: 0.75rem; color: var(--text2); margin-top: 4px; }

/* ‚îÄ‚îÄ Toolbar row ‚îÄ‚îÄ */
.toolbar { display: flex; align-items: center; gap: 16px; margin-top: 16px; flex-wrap: wrap; }
.toolbar-right { margin-left: auto; display: flex; align-items: center; gap: 12px; }

/* ‚îÄ‚îÄ Tooltip ‚îÄ‚îÄ */
[data-tooltip] { position: relative; }
[data-tooltip]:hover::after {
  content: attr(data-tooltip); position: absolute; bottom: calc(100% + 6px); left: 50%; transform: translateX(-50%);
  background: var(--text); color: var(--bg); padding: 4px 10px; border-radius: 6px;
  font-size: 0.7rem; white-space: nowrap; pointer-events: none; z-index: 10;
}

/* ‚îÄ‚îÄ Mobile ‚îÄ‚îÄ */
@media (max-width: 768px) {
  .container { padding: 16px; }
  .row { flex-direction: column; gap: 12px; }
  .toolbar { flex-direction: column; align-items: stretch; gap: 12px; }
  .toolbar-right { margin-left: 0; justify-content: space-between; }
  .tab { padding: 10px 12px; font-size: 0.825rem; }
  .models-table { font-size: 0.75rem; }
  .models-table th, .models-table td { padding: 8px 6px; }
  .dropzone { padding: 24px 16px; }
  .btn, .mic-btn, .seg-opt { min-height: 44px; }
}
</style>
</head>
<body>
<div class="container">
  <!-- Header -->
  <header class="header">
    <div class="header-left">
      <span class="wordmark">Open Speech</span>
      <span class="version-badge" id="version-badge">v1.0</span>
    </div>
    <button class="theme-toggle" onclick="toggleTheme()" data-tooltip="Toggle theme" aria-label="Toggle theme">‚òÄÔ∏è</button>
  </header>

  <!-- Tabs -->
  <div class="tabs" role="tablist">
    <div class="tab active" onclick="switchTab('transcribe')" role="tab" tabindex="0">Transcribe</div>
    <div class="tab" onclick="switchTab('speak')" role="tab" tabindex="0">Speak</div>
    <div class="tab" onclick="switchTab('models')" role="tab" tabindex="0">Models</div>
  </div>

  <!-- TRANSCRIBE TAB -->
  <div id="transcribe" class="panel active" role="tabpanel">
    <div class="card">
      <div class="card-title">Speech to Text</div>
      <div class="row">
        <div class="form-group">
          <label for="stt-model">Model</label>
          <select id="stt-model"></select>
        </div>
        <div class="form-group">
          <label>Output Format</label>
          <div class="segmented" id="stt-format-seg">
            <div class="seg-opt active" data-val="text">Text</div>
            <div class="seg-opt" data-val="json">JSON</div>
            <div class="seg-opt" data-val="srt">SRT</div>
            <div class="seg-opt" data-val="vtt">VTT</div>
          </div>
        </div>
      </div>

      <div class="dropzone" id="stt-dropzone">
        <input type="file" id="stt-file" accept=".wav,.mp3,.ogg,.flac,.m4a,.webm">
        <span class="dropzone-icon">üìÅ</span>
        <span class="dropzone-label">Drop audio file here or click to browse</span>
        <div class="dropzone-hint">wav, mp3, ogg, flac, m4a, webm</div>
      </div>

      <div class="toolbar">
        <button class="mic-btn" id="mic-btn" onclick="toggleMic()" data-tooltip="Live microphone" aria-label="Toggle microphone">üéôÔ∏è</button>
        <span class="ws-status"><span class="ws-dot" id="ws-dot"></span> <span id="ws-label">Disconnected</span></span>
        <span class="ws-status"><span class="vad-indicator idle" id="vad-dot"></span> <span id="vad-label">Silence</span></span>
        <div class="toolbar-right">
          <button class="btn btn-ghost btn-sm" id="stt-download" onclick="downloadTranscript()" disabled>‚¨á Download</button>
        </div>
      </div>
      <div style="margin-top:12px;background:var(--elevated);border:1px solid var(--border);border-radius:var(--radius-sm);padding:10px 12px">
        <div style="font-size:0.75rem;color:var(--text2);margin-bottom:6px">Live input level</div>
        <canvas id="level-meter" width="820" height="50" style="width:100%;height:50px;border-radius:6px;background:rgba(99,102,241,0.06)"></canvas>
      </div>
    </div>

    <div class="card">
      <div class="card-title">Result</div>
      <div style="display:grid;gap:10px">
        <div>
          <label style="margin-bottom:4px">Partial transcription</label>
          <div class="result-area" id="stt-partial"><span class="result-placeholder">Partial results will stream here‚Ä¶</span></div>
        </div>
        <div>
          <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:4px">
            <label style="margin:0">Final transcription</label>
            <button class="btn btn-ghost btn-sm" id="copy-final-btn" onclick="copyFinalTranscript()" disabled>üìã Copy</button>
          </div>
          <div class="result-area" id="stt-result" style="font-weight:600"></div>
          <div style="font-size:0.78rem;color:var(--text2);margin-top:6px" id="stt-metrics">Duration: ‚Äî ¬∑ Processing: ‚Äî</div>
        </div>
      </div>
    </div>

    <div class="history" id="stt-history-wrap">
      <div class="history-toggle" onclick="toggleHistory('stt')">
        <span class="arrow" id="stt-arrow">‚ñ∂</span> Recent Transcriptions
      </div>
      <div class="history-items" id="stt-history"></div>
    </div>
  </div>

  <!-- SPEAK TAB -->
  <div id="speak" class="panel" role="tabpanel">
    <div class="card">
      <div class="card-title">Text to Speech</div>
      <div class="form-group">
        <div style="display:flex;align-items:center;justify-content:space-between">
          <label for="tts-text" style="margin:0">Text</label>
          <button class="btn btn-ghost btn-sm" onclick="document.getElementById('tts-file').click()" style="padding:4px 10px;font-size:0.75rem">üìÑ Upload .txt</button>
          <input type="file" id="tts-file" accept=".txt" style="display:none">
        </div>
        <textarea id="tts-text" placeholder="Enter text to synthesize‚Ä¶" maxlength="5000" oninput="updateCharCount()"></textarea>
        <div class="char-count"><span id="char-count">0</span> / 5,000</div>
      </div>

      <div class="row">
        <div class="form-group">
          <label for="tts-model">Model</label>
          <select id="tts-model" onchange="onTTSModelChanged()"></select>
        </div>
        <div class="form-group">
          <label for="tts-preset">Preset</label>
          <select id="tts-preset" onchange="applyPreset()">
            <option value="">‚Äî Custom ‚Äî</option>
          </select>
        </div>
      </div>

      <div class="row">
        <div class="form-group">
          <label for="tts-voice">Voice</label>
          <select id="tts-voice"></select>
          <input type="text" id="tts-voice-text" placeholder="Enter voice name" style="display:none;margin-top:6px">
        </div>
        <div class="form-group" style="flex:1.5">
          <label>Voice Blend</label>
          <div id="blend-tags" style="display:flex;flex-wrap:wrap;gap:6px;min-height:36px;padding:8px;background:var(--elevated);border:1px solid var(--border);border-radius:var(--radius-sm);align-items:center">
            <span style="color:var(--text2);font-size:0.8rem" id="blend-hint">Click + to add voices to blend</span>
          </div>
          <div style="display:flex;gap:6px;margin-top:6px;align-items:center">
            <select id="blend-voice-select" style="flex:1;font-size:0.825rem"></select>
            <input type="number" id="blend-weight" min="0.1" max="10" step="0.1" value="1.0" style="width:60px;font-size:0.825rem" title="Weight">
            <button class="btn btn-sm" onclick="addBlendVoice()" style="padding:4px 10px;font-size:0.825rem" title="Add voice to blend">Ôºã</button>
          </div>
          <input type="hidden" id="tts-blend" value="">
        </div>
      </div>

      <div class="row">
        <div class="form-group">
          <label>Speed: <strong id="speed-val">1.0</strong>x</label>
          <input type="range" id="tts-speed" min="0.5" max="4.0" step="0.05" value="1.0" oninput="document.getElementById('speed-val').textContent=this.value">
        </div>
        <div class="form-group">
          <label>Format</label>
          <div class="segmented" id="tts-format-seg">
            <div class="seg-opt active" data-val="mp3">MP3</div>
            <div class="seg-opt" data-val="wav">WAV</div>
            <div class="seg-opt" data-val="opus">Opus</div>
            <div class="seg-opt" data-val="flac">FLAC</div>
          </div>
        </div>
      </div>

      <div class="row">
        <div class="form-group" id="tts-language-group" style="display:none">
          <label for="tts-language">Language</label>
          <select id="tts-language"></select>
        </div>
        <div class="form-group" id="tts-voice-design-group">
          <label for="tts-voice-design">Voice Design</label>
          <input type="text" id="tts-voice-design" placeholder="e.g., speak warmly and calmly">
        </div>
      </div>

      <div class="toolbar">
        <button class="btn" id="speak-btn" onclick="doSpeak()"><span class="spinner"></span> Generate</button>
        <div class="switch-wrap">
          <label class="switch"><input type="checkbox" id="tts-stream"><span class="switch-track"></span></label>
          <span id="tts-stream-label" style="font-size:0.825rem;color:var(--text2)" title="Start playback before generation finishes ‚Äî lower latency for long text">Stream</span>
        </div>
        <div class="switch-wrap">
          <label class="switch"><input type="checkbox" id="tts-ssml"><span class="switch-track"></span></label>
          <span id="tts-ssml-label" style="font-size:0.825rem;color:var(--text2)">SSML</span>
        </div>
      </div>
    </div>

    <!-- Audio Player -->
    <div class="audio-player" id="audio-player">
      <button class="play-btn" id="play-btn" onclick="togglePlayback()">‚ñ∂</button>
      <div class="audio-progress">
        <div class="progress-bar" id="progress-bar" onclick="seekAudio(event)">
          <div class="progress-fill" id="progress-fill"></div>
        </div>
        <div class="audio-time"><span id="audio-current">0:00</span> / <span id="audio-duration">0:00</span></div>
      </div>
      <button class="btn btn-ghost btn-sm" id="tts-download-btn" onclick="downloadAudio()">‚¨á</button>
    </div>
    <audio id="tts-audio" style="display:none"></audio>

    <div class="history" id="tts-history-wrap">
      <div class="history-toggle" onclick="toggleHistory('tts')">
        <span class="arrow" id="tts-arrow">‚ñ∂</span> Recent Generations
      </div>
      <div class="history-items" id="tts-history"></div>
    </div>
  </div>

  <!-- MODELS TAB -->
  <div id="models" class="panel" role="tabpanel">
    <!-- Loaded Models -->
    <div class="card">
      <div class="models-header">
        <div>
          <div class="card-title" style="margin-bottom:4px">Loaded Models</div>
          <div class="models-count" id="models-count">0 models loaded</div>
        </div>
        <span class="refresh-icon" id="refresh-icon" data-tooltip="Auto-refreshes every 10s">üîÑ</span>
      </div>
      <div style="overflow-x:auto">
        <table class="models-table">
          <thead><tr><th>Model</th><th>Type</th><th>Provider</th><th>Device</th><th>Action</th></tr></thead>
          <tbody id="models-body"></tbody>
        </table>
        <div id="no-loaded" style="padding:20px;text-align:center;color:var(--text2);font-size:0.85rem;display:none">No models loaded</div>
      </div>
    </div>
    <!-- Available Models -->
    <div class="card" style="margin-top:16px">
      <div class="card-title" style="margin-bottom:16px">Available Models</div>
      <!-- STT -->
      <div style="margin-bottom:20px">
        <div style="font-size:0.8rem;font-weight:600;text-transform:uppercase;letter-spacing:0.05em;color:var(--text2);margin-bottom:8px">
          <span class="badge badge-stt" style="margin-right:6px">STT</span> Speech-to-Text Models
        </div>
        <div style="overflow-x:auto">
          <table class="models-table">
            <thead><tr><th>Model</th><th>Provider</th><th>Size</th><th>Description</th><th>Status</th><th>Action</th></tr></thead>
            <tbody id="available-stt-body"></tbody>
          </table>
        </div>
      </div>
      <!-- TTS -->
      <div>
        <div style="font-size:0.8rem;font-weight:600;text-transform:uppercase;letter-spacing:0.05em;color:var(--text2);margin-bottom:8px">
          <span class="badge badge-tts" style="margin-right:6px">TTS</span> Text-to-Speech Models
        </div>
        <div style="overflow-x:auto">
          <table class="models-table">
            <thead><tr><th>Model</th><th>Provider</th><th>Size</th><th>Description</th><th>Status</th><th>Action</th></tr></thead>
            <tbody id="available-tts-body"></tbody>
          </table>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- Toast Container -->
<div class="toast-container" id="toast-container"></div>

<script>
/* ‚îÄ‚îÄ Theme ‚îÄ‚îÄ */
function getPreferredTheme() {
  const stored = localStorage.getItem('os-theme');
  if (stored) return stored;
  return window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
}
function applyTheme(t) {
  document.documentElement.setAttribute('data-theme', t);
  document.querySelector('.theme-toggle').textContent = t === 'dark' ? '‚òÄÔ∏è' : 'üåô';
}
function toggleTheme() {
  const next = document.documentElement.getAttribute('data-theme') === 'dark' ? 'light' : 'dark';
  localStorage.setItem('os-theme', next);
  applyTheme(next);
}
applyTheme(getPreferredTheme());
window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', e => {
  if (!localStorage.getItem('os-theme')) applyTheme(e.matches ? 'dark' : 'light');
});

/* ‚îÄ‚îÄ Toast ‚îÄ‚îÄ */
function toast(msg, type='success') {
  const c = document.getElementById('toast-container');
  const el = document.createElement('div');
  el.className = `toast toast-${type}`;
  el.innerHTML = `<span class="toast-dot"></span>${msg}`;
  c.appendChild(el);
  setTimeout(() => { el.classList.add('removing'); setTimeout(() => el.remove(), 300); }, 3000);
}

/* ‚îÄ‚îÄ Segmented Controls ‚îÄ‚îÄ */
document.querySelectorAll('.segmented').forEach(seg => {
  seg.querySelectorAll('.seg-opt').forEach(opt => {
    opt.addEventListener('click', () => {
      seg.querySelectorAll('.seg-opt').forEach(o => o.classList.remove('active'));
      opt.classList.add('active');
    });
  });
});
function getSegVal(id) { return document.querySelector(`#${id} .seg-opt.active`).dataset.val; }

/* ‚îÄ‚îÄ Tabs ‚îÄ‚îÄ */
function switchTab(name) {
  document.querySelectorAll('.tab').forEach((t,i) => {
    t.classList.toggle('active', ['transcribe','speak','models'][i] === name);
  });
  document.querySelectorAll('.panel').forEach(p => {
    p.classList.remove('active');
    if (p.id === name) p.classList.add('active');
  });
  if (name === 'models') refreshModels();
}

/* ‚îÄ‚îÄ History toggle ‚îÄ‚îÄ */
function toggleHistory(prefix) {
  const items = document.getElementById(prefix + '-history');
  const arrow = document.getElementById(prefix + '-arrow');
  items.classList.toggle('open');
  arrow.classList.toggle('open');
}

/* ‚îÄ‚îÄ Char count ‚îÄ‚îÄ */
function updateCharCount() {
  document.getElementById('char-count').textContent = document.getElementById('tts-text').value.length;
}

/* ‚îÄ‚îÄ STT ‚îÄ‚îÄ */
let sttHistory = [];
let lastTranscript = '';
let lastTranscriptFormat = 'text';

async function loadSTTModels() {
  try {
    const r = await fetch('/api/models');
    const data = await r.json();
    const sel = document.getElementById('stt-model');
    sel.innerHTML = '';
    (data.models || []).forEach(m => {
      if (m.type !== 'stt' || m.state !== 'loaded') return;
      const o = document.createElement('option');
      o.value = m.id; o.textContent = m.id;
      sel.appendChild(o);
    });
  } catch(e) { console.error('Failed to load models', e); }
}

const sttDZ = document.getElementById('stt-dropzone');
const sttFile = document.getElementById('stt-file');
sttDZ.onclick = () => sttFile.click();
sttDZ.ondragover = e => { e.preventDefault(); sttDZ.classList.add('dragover'); };
sttDZ.ondragleave = () => sttDZ.classList.remove('dragover');
sttDZ.ondrop = e => { e.preventDefault(); sttDZ.classList.remove('dragover'); if(e.dataTransfer.files.length) transcribeFile(e.dataTransfer.files[0]); };
sttFile.onchange = () => { if(sttFile.files.length) transcribeFile(sttFile.files[0]); };

async function transcribeFile(file) {
  const res = document.getElementById('stt-result');
  const partialEl = document.getElementById('stt-partial');
  res.innerHTML = '<span class="result-placeholder">Transcribing‚Ä¶</span>';
  partialEl.innerHTML = '<span class="result-placeholder">Uploading file‚Ä¶</span>';
  const fmt = getSegVal('stt-format-seg');
  const model = document.getElementById('stt-model').value;
  const fd = new FormData();
  fd.append('file', file);
  fd.append('model', model);
  fd.append('response_format', fmt === 'json' ? 'verbose_json' : fmt);
  try {
    const r = await fetch('/v1/audio/transcriptions', { method: 'POST', body: fd });
    const ct = r.headers.get('content-type') || '';
    if (ct.includes('json')) {
      const data = await r.json();
      lastTranscript = JSON.stringify(data, null, 2);
      lastTranscriptFormat = 'json';
      res.textContent = data.text || lastTranscript;
    } else {
      lastTranscript = await r.text();
      lastTranscriptFormat = fmt;
      res.textContent = lastTranscript;
    }
    partialEl.innerHTML = '<span class="result-placeholder">No live partials for file mode</span>';
    document.getElementById('copy-final-btn').disabled = false;
    document.getElementById('stt-download').disabled = false;
    addSTTHistory(file.name, res.textContent.substring(0, 80));
    toast('Transcription complete');
  } catch(e) {
    res.textContent = 'Error: ' + e.message;
    toast('Transcription failed: ' + e.message, 'error');
  }
}

function downloadTranscript() {
  if (!lastTranscript) return;
  const ext = {text:'.txt', json:'.json', srt:'.srt', vtt:'.vtt'}[lastTranscriptFormat] || '.txt';
  const blob = new Blob([lastTranscript], {type:'text/plain'});
  const a = document.createElement('a'); a.href = URL.createObjectURL(blob);
  a.download = 'transcript' + ext; a.click();
}

async function copyFinalTranscript() {
  if (!lastTranscript) return;
  await navigator.clipboard.writeText(lastTranscript);
  toast('Final transcription copied');
}

function addSTTHistory(name, preview) {
  sttHistory.unshift({name, preview, time: new Date().toLocaleTimeString()});
  if (sttHistory.length > 5) sttHistory.pop();
  renderSTTHistory();
}
function renderSTTHistory() {
  const el = document.getElementById('stt-history');
  el.innerHTML = '';
  sttHistory.forEach(h => {
    const d = document.createElement('div');
    d.className = 'history-item';
    d.innerHTML = `<div class="preview">${h.preview}‚Ä¶</div><div class="meta">${h.name} ¬∑ ${h.time}</div>`;
    el.appendChild(d);
  });
}

/* ‚îÄ‚îÄ Live Mic ‚îÄ‚îÄ */
let mediaRecorder = null;
let wsConn = null;
let micState = 'idle'; // idle, listening, speech, processing
let meterAnim = null;
let meterAnalyser = null;
let meterData = null;
let recordingStartedAt = 0;
let speechEndedAt = 0;

function setMicState(state) {
  micState = state;
  const btn = document.getElementById('mic-btn');
  const vadDot = document.getElementById('vad-dot');
  const vadLabel = document.getElementById('vad-label');
  btn.classList.remove('recording', 'speech');
  vadDot.className = 'vad-indicator idle';
  vadLabel.textContent = 'Silence';
  if (state === 'listening') {
    btn.classList.add('recording');
    btn.textContent = '‚èπ';
    vadDot.className = 'vad-indicator listening';
    vadLabel.textContent = 'Listening';
  } else if (state === 'speech') {
    btn.classList.add('recording', 'speech');
    btn.textContent = '‚èπ';
    vadDot.className = 'vad-indicator speech';
    vadLabel.textContent = 'Speech';
  } else if (state === 'processing') {
    btn.classList.add('recording');
    btn.textContent = '‚èπ';
    vadDot.className = 'vad-indicator processing';
    vadLabel.textContent = 'Processing';
  } else {
    btn.textContent = 'üéôÔ∏è';
  }
}

function toggleMic() {
  if (mediaRecorder && mediaRecorder.state === 'recording') stopMic(); else startMic();
}

async function startMic() {
  const res = document.getElementById('stt-result');
  const partialEl = document.getElementById('stt-partial');
  document.getElementById('copy-final-btn').disabled = true;
  document.getElementById('stt-metrics').textContent = 'Duration: ‚Äî ¬∑ Processing: ‚Äî';
  recordingStartedAt = performance.now();
  try {
    const stream = await navigator.mediaDevices.getUserMedia({audio: {sampleRate: 16000, channelCount: 1}});
    const model = document.getElementById('stt-model').value;
    const proto = location.protocol === 'https:' ? 'wss:' : 'ws:';
    wsConn = new WebSocket(`${proto}//${location.host}/v1/audio/stream?model=${encodeURIComponent(model)}&sample_rate=16000&vad=true`);
    wsConn.onopen = () => {
      document.getElementById('ws-dot').classList.add('connected');
      document.getElementById('ws-label').textContent = 'Connected';
      setMicState('listening');
      partialEl.innerHTML = '<span class="result-placeholder">Listening ‚Äî partial transcript will stream here‚Ä¶</span>';
      res.innerHTML = '<span class="result-placeholder">Final transcription will appear here‚Ä¶</span>';
    };
    wsConn.onclose = () => {
      document.getElementById('ws-dot').classList.remove('connected');
      document.getElementById('ws-label').textContent = 'Disconnected';
    };
    wsConn.onerror = (err) => {
      console.error('WebSocket error', err);
      toast('WebSocket connection failed ‚Äî check server is running', 'error');
      res.innerHTML = '<span class="result-placeholder" style="color:var(--error)">WebSocket connection failed</span>';
      stopMic();
    };
    let fullText = '';
    wsConn.onmessage = e => {
      const msg = JSON.parse(e.data);
      if (msg.type === 'vad') {
        if (msg.state === 'speech_start') {
          setMicState('speech');
        } else if (msg.state === 'speech_end') {
          setMicState('processing');
          speechEndedAt = performance.now();
        }
      } else if (msg.type === 'transcript') {
        if (msg.speech_final || msg.is_final) {
          fullText = (fullText + ' ' + (msg.text || '')).trim();
          res.textContent = fullText;
          partialEl.innerHTML = '<span class="result-placeholder">Waiting for next utterance‚Ä¶</span>';
          const total = ((performance.now() - recordingStartedAt) / 1000).toFixed(2);
          const proc = speechEndedAt ? ((performance.now() - speechEndedAt) / 1000).toFixed(2) : '0.00';
          document.getElementById('stt-metrics').textContent = `Duration: ${total}s ¬∑ Processing: ${proc}s`;
          setMicState('listening');
        } else {
          partialEl.innerHTML = '<span class="partial">' + (msg.text || '') + '</span>';
        }
        lastTranscript = fullText || (msg.text || '');
        lastTranscriptFormat = 'text';
        document.getElementById('copy-final-btn').disabled = !lastTranscript;
        document.getElementById('stt-download').disabled = false;
      } else if (msg.type === 'error') {
        toast('Transcription error: ' + msg.message, 'error');
      }
    };
    const audioCtx = new AudioContext({sampleRate: 16000});
    const source = audioCtx.createMediaStreamSource(stream);
    meterAnalyser = audioCtx.createAnalyser();
    meterAnalyser.fftSize = 1024;
    meterData = new Uint8Array(meterAnalyser.frequencyBinCount);
    const processor = audioCtx.createScriptProcessor(4096, 1, 1);
    processor.onaudioprocess = e => {
      if (wsConn && wsConn.readyState === WebSocket.OPEN) {
        const f32 = e.inputBuffer.getChannelData(0);
        const i16 = new Int16Array(f32.length);
        for (let i = 0; i < f32.length; i++) i16[i] = Math.max(-32768, Math.min(32767, f32[i] * 32768));
        wsConn.send(i16.buffer);
      }
    };
    source.connect(meterAnalyser);
    meterAnalyser.connect(processor);
    processor.connect(audioCtx.destination);

    const canvas = document.getElementById('level-meter');
    const ctx = canvas.getContext('2d');
    const drawMeter = () => {
      if (!meterAnalyser || !meterData || !ctx) return;
      meterAnalyser.getByteTimeDomainData(meterData);
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.beginPath();
      for (let i = 0; i < meterData.length; i++) {
        const x = (i / meterData.length) * canvas.width;
        const y = (meterData[i] / 255) * canvas.height;
        i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
      }
      ctx.strokeStyle = '#6366f1';
      ctx.lineWidth = 2;
      ctx.stroke();
      meterAnim = requestAnimationFrame(drawMeter);
    };
    drawMeter();

    mediaRecorder = {state:'recording', stop: () => {
      if (meterAnim) cancelAnimationFrame(meterAnim);
      processor.disconnect();
      meterAnalyser.disconnect();
      source.disconnect();
      audioCtx.close();
      stream.getTracks().forEach(t => t.stop());
      if (wsConn && wsConn.readyState === WebSocket.OPEN) { wsConn.send(JSON.stringify({type:'stop'})); wsConn.close(); }
      mediaRecorder = null;
    }};
    setMicState('listening');
    res.innerHTML = '<span class="result-placeholder"><span class="vad-indicator listening"></span>Connecting‚Ä¶</span>';
  } catch(e) {
    const msg = e.name === 'NotAllowedError' ? 'Microphone access denied ‚Äî please allow mic access in browser settings'
      : e.name === 'NotFoundError' ? 'No microphone found ‚Äî please connect a microphone'
      : 'Mic error: ' + e.message;
    toast(msg, 'error');
    res.innerHTML = `<span class="result-placeholder" style="color:var(--error)">${msg}</span>`;
  }
}

function stopMic() {
  if (mediaRecorder) mediaRecorder.stop();
  setMicState('idle');
  addSTTHistory('Microphone', document.getElementById('stt-result').textContent.substring(0, 80));
}

/* ‚îÄ‚îÄ TTS ‚îÄ‚îÄ */
let ttsHistory = [];
let currentAudioUrl = null;
let currentAudioFmt = 'mp3';
let currentTTSCapabilities = null;
let currentTTSBackend = 'kokoro';

async function loadTTSModels() {
  try {
    const r = await fetch('/api/models');
    const data = await r.json();
    const sel = document.getElementById('tts-model');
    sel.innerHTML = '';
    const ttsModels = (data.models || []).filter(m => m.type === 'tts');
    ttsModels.forEach(m => {
      const o = document.createElement('option');
      o.value = m.id;
      o.textContent = m.id;
      if (m.is_default) o.selected = true;
      sel.appendChild(o);
    });
    if (!sel.value && ttsModels.length) sel.value = ttsModels[0].id;
  } catch (e) { console.error('Failed to load TTS models', e); }
}

function setDisabledWithTooltip(el, disabled, tooltip) {
  if (!el) return;
  el.disabled = !!disabled;
  el.style.opacity = disabled ? '0.5' : '';
  el.style.cursor = disabled ? 'not-allowed' : '';
  if (tooltip) el.title = tooltip;
}

function populateSpeakerUI(speakers) {
  const sel = document.getElementById('tts-voice');
  const text = document.getElementById('tts-voice-text');
  const blendSel = document.getElementById('blend-voice-select');
  sel.innerHTML = '';
  blendSel.innerHTML = '';

  if (speakers && speakers.length) {
    sel.style.display = '';
    text.style.display = 'none';
    speakers.forEach((sp, idx) => {
      const o = document.createElement('option');
      o.value = sp.name;
      o.textContent = sp.description ? `${sp.name} ‚Äî ${sp.description}` : sp.name;
      if (sp.description) o.title = sp.description;
      if (idx === 0) o.selected = true;
      sel.appendChild(o);
      blendSel.appendChild(o.cloneNode(true));
    });
  } else {
    sel.style.display = 'none';
    text.style.display = '';
    text.value = 'default';
  }
}

function applyTTSCapabilities(capabilities, backendName) {
  currentTTSCapabilities = capabilities || {};
  currentTTSBackend = backendName || 'kokoro';

  populateSpeakerUI(currentTTSCapabilities.speakers || []);

  const voiceDesignInput = document.getElementById('tts-voice-design');
  if (currentTTSCapabilities.voice_design) {
    setDisabledWithTooltip(voiceDesignInput, false, '');
  } else {
    setDisabledWithTooltip(voiceDesignInput, true, `Not supported by ${backendName} ‚Äî switch to Qwen3`);
    voiceDesignInput.value = '';
  }

  const langs = currentTTSCapabilities.languages || ['en-us'];
  const langGroup = document.getElementById('tts-language-group');
  const langSel = document.getElementById('tts-language');
  const previousLang = langSel.value;
  langSel.innerHTML = '';
  langs.forEach((lang) => {
    const o = document.createElement('option');
    o.value = lang;
    o.textContent = lang;
    // Preserve user choice when possible; otherwise default to en-us, then en, then Auto.
    if (previousLang && lang.toLowerCase() === previousLang.toLowerCase()) {
      o.selected = true;
    } else if (!previousLang && (lang.toLowerCase() === 'en-us' || lang.toLowerCase() === 'en' || lang === 'Auto')) {
      if (!langSel.querySelector('option[selected]')) o.selected = true;
    }
    langSel.appendChild(o);
  });
  if (!langSel.value && langSel.options.length > 0) {
    langSel.options[0].selected = true;
  }
  langGroup.style.display = langs.length > 1 ? '' : 'none';

  const streamToggle = document.getElementById('tts-stream');
  setDisabledWithTooltip(streamToggle, !currentTTSCapabilities.streaming, `Stream not supported by ${backendName}`);
  if (!currentTTSCapabilities.streaming) streamToggle.checked = false;

  const ssmlToggle = document.getElementById('tts-ssml');
  const ssmlSupported = currentTTSCapabilities.ssml === true || currentTTSCapabilities.ssml === 'partial';
  setDisabledWithTooltip(ssmlToggle, !ssmlSupported, `SSML not supported by ${backendName}`);
  if (!ssmlSupported) ssmlToggle.checked = false;
}

async function loadTTSCapabilities() {
  try {
    const model = document.getElementById('tts-model').value;
    const url = model ? `/api/tts/capabilities?model=${encodeURIComponent(model)}` : '/api/tts/capabilities';
    const r = await fetch(url);
    const data = await r.json();
    applyTTSCapabilities(data.capabilities || {}, data.backend || 'kokoro');
  } catch (e) {
    console.error('Failed to load TTS capabilities', e);
  }
}

async function onTTSModelChanged() {
  await loadTTSCapabilities();
}

// TTS file upload
const ttsFileInput = document.getElementById('tts-file');
ttsFileInput.onchange = () => {
  if (ttsFileInput.files.length) {
    const reader = new FileReader();
    reader.onload = e => { document.getElementById('tts-text').value = e.target.result; updateCharCount(); };
    reader.readAsText(ttsFileInput.files[0]);
  }
};

async function doSpeak() {
  const btn = document.getElementById('speak-btn');
  btn.disabled = true; btn.classList.add('loading');
  btn.querySelector('.spinner').style.display = 'block';
  const text = document.getElementById('tts-text').value;
  const model = document.getElementById('tts-model').value || 'kokoro';
  const blend = document.getElementById('tts-blend').value;
  const voiceSelect = document.getElementById('tts-voice');
  const voiceText = document.getElementById('tts-voice-text');
  const baseVoice = voiceSelect.style.display === 'none' ? (voiceText.value || 'default') : voiceSelect.value;
  const voice = blend || baseVoice;
  const speed = parseFloat(document.getElementById('tts-speed').value);
  const fmt = getSegVal('tts-format-seg');
  const language = document.getElementById('tts-language').value || null;
  const voiceDesign = document.getElementById('tts-voice-design').value || null;
  const inputType = document.getElementById('tts-ssml').checked ? 'ssml' : 'text';
  const doStream = document.getElementById('tts-stream').checked;
  try {
    const url = '/v1/audio/speech' + (doStream ? '?stream=true' : '');
    const r = await fetch(url, {
      method: 'POST', headers: {'Content-Type': 'application/json'},
      body: JSON.stringify({model, input: text, voice, speed, response_format: fmt, language, voice_design: voiceDesign, input_type: inputType}),
    });
    if (!r.ok) {
      const err = await r.json().catch(() => ({}));
      throw new Error(err.error || err.detail || `HTTP ${r.status}`);
    }
    const blob = await r.blob();
    if (currentAudioUrl) URL.revokeObjectURL(currentAudioUrl);
    currentAudioUrl = URL.createObjectURL(blob);
    currentAudioFmt = fmt;
    const audio = document.getElementById('tts-audio');
    audio.src = currentAudioUrl;
    document.getElementById('audio-player').classList.add('visible');
    audio.play();
    document.getElementById('play-btn').textContent = '‚è∏';
    addTTSHistory(text.substring(0, 60), voice, blob, fmt);
    toast('Audio generated');
  } catch(e) {
    toast('TTS error: ' + e.message, 'error');
  } finally {
    btn.disabled = false; btn.classList.remove('loading');
    btn.querySelector('.spinner').style.display = 'none';
  }
}

/* ‚îÄ‚îÄ Voice Blend Builder ‚îÄ‚îÄ */
const blendVoices = [];
function addBlendVoice() {
  const sel = document.getElementById('blend-voice-select');
  const weight = parseFloat(document.getElementById('blend-weight').value) || 1.0;
  const voiceId = sel.value;
  if (!voiceId) return;
  blendVoices.push({id: voiceId, weight});
  renderBlendTags();
}
function removeBlendVoice(idx) {
  blendVoices.splice(idx, 1);
  renderBlendTags();
}
function renderBlendTags() {
  const container = document.getElementById('blend-tags');
  const hint = document.getElementById('blend-hint');
  if (blendVoices.length === 0) {
    container.innerHTML = '<span style="color:var(--text2);font-size:0.8rem" id="blend-hint">Click + to add voices to blend</span>';
    document.getElementById('tts-blend').value = '';
    return;
  }
  container.innerHTML = blendVoices.map((v, i) =>
    `<span style="display:inline-flex;align-items:center;gap:4px;padding:3px 8px;background:var(--accent);color:#fff;border-radius:20px;font-size:0.78rem;font-weight:500">${v.id}<span style="opacity:0.7">(${v.weight})</span><span onclick="removeBlendVoice(${i})" style="cursor:pointer;margin-left:2px;opacity:0.7;font-size:0.9rem" title="Remove">√ó</span></span>`
  ).join('');
  document.getElementById('tts-blend').value = blendVoices.map(v => `${v.id}(${v.weight})`).join('+');
}

/* ‚îÄ‚îÄ Custom Audio Player ‚îÄ‚îÄ */
const audioEl = document.getElementById('tts-audio');
audioEl.addEventListener('timeupdate', () => {
  if (audioEl.duration) {
    document.getElementById('progress-fill').style.width = (audioEl.currentTime / audioEl.duration * 100) + '%';
    document.getElementById('audio-current').textContent = fmtTime(audioEl.currentTime);
  }
});
audioEl.addEventListener('loadedmetadata', () => {
  document.getElementById('audio-duration').textContent = fmtTime(audioEl.duration);
});
audioEl.addEventListener('ended', () => { document.getElementById('play-btn').textContent = '‚ñ∂'; });
audioEl.addEventListener('play', () => { document.getElementById('play-btn').textContent = '‚è∏'; });
audioEl.addEventListener('pause', () => { document.getElementById('play-btn').textContent = '‚ñ∂'; });

function togglePlayback() { audioEl.paused ? audioEl.play() : audioEl.pause(); }
function seekAudio(e) {
  const bar = document.getElementById('progress-bar');
  const pct = e.offsetX / bar.offsetWidth;
  audioEl.currentTime = pct * audioEl.duration;
}
function fmtTime(s) { const m = Math.floor(s/60); return m + ':' + String(Math.floor(s%60)).padStart(2,'0'); }
function downloadAudio() {
  if (!currentAudioUrl) return;
  const a = document.createElement('a'); a.href = currentAudioUrl;
  a.download = 'speech.' + currentAudioFmt; a.click();
}

function addTTSHistory(preview, voice, blob, fmt) {
  ttsHistory.unshift({preview, voice, time: new Date().toLocaleTimeString(), blob: blob || null, fmt: fmt || 'mp3'});
  if (ttsHistory.length > 5) { const old = ttsHistory.pop(); if (old && old.blobUrl) URL.revokeObjectURL(old.blobUrl); }
  renderTTSHistory();
}
function deleteTTSHistory(idx) {
  const removed = ttsHistory.splice(idx, 1);
  if (removed[0] && removed[0].blobUrl) URL.revokeObjectURL(removed[0].blobUrl);
  renderTTSHistory();
}
function downloadTTSHistory(idx) {
  const h = ttsHistory[idx];
  if (!h || !h.blob) return;
  const url = URL.createObjectURL(h.blob);
  const a = document.createElement('a'); a.href = url; a.download = 'speech.' + h.fmt; a.click();
  setTimeout(() => URL.revokeObjectURL(url), 1000);
}
function renderTTSHistory() {
  const el = document.getElementById('tts-history');
  el.innerHTML = '';
  ttsHistory.forEach((h, i) => {
    const d = document.createElement('div');
    d.className = 'history-item';
    d.style.display = 'flex'; d.style.alignItems = 'center'; d.style.justifyContent = 'space-between';
    const left = document.createElement('div');
    left.style.cursor = 'pointer'; left.style.flex = '1';
    left.innerHTML = `<div class="preview">${h.preview}‚Ä¶</div><div class="meta">${h.voice} ¬∑ ${h.time}</div>`;
    left.onclick = () => { document.getElementById('tts-text').value = h.preview; updateCharCount(); };
    const btns = document.createElement('div');
    btns.style.display = 'flex'; btns.style.gap = '4px'; btns.style.flexShrink = '0';
    if (h.blob) {
      const dl = document.createElement('button');
      dl.className = 'btn btn-ghost btn-sm'; dl.style.padding = '4px 8px'; dl.style.fontSize = '0.8rem';
      dl.textContent = '‚¨á'; dl.title = 'Download'; dl.onclick = (e) => { e.stopPropagation(); downloadTTSHistory(i); };
      btns.appendChild(dl);
    }
    const del = document.createElement('button');
    del.className = 'btn btn-ghost btn-sm'; del.style.padding = '4px 8px'; del.style.fontSize = '0.8rem';
    del.textContent = '‚úï'; del.title = 'Delete'; del.onclick = (e) => { e.stopPropagation(); deleteTTSHistory(i); };
    btns.appendChild(del);
    d.appendChild(left); d.appendChild(btns);
    el.appendChild(d);
  });
}

/* ‚îÄ‚îÄ Models (unified /api/models endpoint) ‚îÄ‚îÄ */
let modelsInterval = null;
let _loadingModels = new Set();
let _providerInstallProgress = new Map();
let _providerInstallPollers = new Map();

// Add CSS for model browser badges
(() => {
  const s = document.createElement('style');
  s.textContent = `
    .badge-downloaded{background:rgba(59,130,246,0.12);color:#3b82f6;}
    .badge-available{background:rgba(156,163,175,0.12);color:#9ca3af;}
    .badge-provider_missing{background:rgba(239,68,68,0.14);color:#ef4444;}
    .badge-provider_installed{background:rgba(34,197,94,0.14);color:#22c55e;}
    .badge-downloading{background:rgba(234,179,8,0.14);color:#ca8a04;}
    .model-spinner{display:inline-block;width:14px;height:14px;border:2px solid var(--border);border-top-color:var(--accent);border-radius:50%;animation:spin 0.6s linear infinite;margin-right:6px;vertical-align:middle;}
    @keyframes spin{to{transform:rotate(360deg)}}
  `;
  document.head.appendChild(s);
})();

function formatSize(mb) {
  if (!mb) return '‚Äî';
  return mb >= 1000 ? (mb / 1000).toFixed(1) + ' GB' : mb + ' MB';
}

function statebadge(state) {
  const cls = {loaded:'badge-loaded', downloaded:'badge-downloaded', available:'badge-available'};
  const lbl = {loaded:'Loaded', downloaded:'Downloaded', available:'Available'};
  return `<span class="badge ${cls[state]||'badge-available'}">${lbl[state]||state}</span>`;
}

async function refreshModels() {
  const icon = document.getElementById('refresh-icon');
  icon.classList.add('spinning');
  try {
    const r = await fetch('/api/models');
    const data = await r.json();
    const models = data.models || [];

    // Loaded models table
    const loadedBody = document.getElementById('models-body');
    const noLoaded = document.getElementById('no-loaded');
    loadedBody.innerHTML = '';
    const loaded = models.filter(m => m.state === 'loaded');
    loaded.sort((a,b) => a.id.localeCompare(b.id));

    if (loaded.length === 0) {
      noLoaded.style.display = '';
    } else {
      noLoaded.style.display = 'none';
      loaded.forEach(m => {
        const tr = document.createElement('tr');
        const typeBadge = `<span class="badge badge-${m.type}">${m.type.toUpperCase()}</span>`;
        const defaultBadge = m.is_default ? ' <span class="badge" style="background:rgba(99,102,241,0.12);color:var(--accent);margin-left:4px">Default</span>' : '';
        let action = m.is_default
          ? `<button class="btn btn-sm" disabled style="opacity:0.4;cursor:not-allowed">Default</button>`
          : `<button class="btn btn-danger btn-sm" onclick="unloadModel('${m.id}')">Unload</button>`;
        tr.innerHTML = `<td><strong>${m.id}</strong>${defaultBadge}</td><td>${typeBadge}</td><td>${m.provider||'‚Äî'}</td><td>${m.device||'‚Äî'}</td><td>${action}</td>`;
        loadedBody.appendChild(tr);
      });
    }
    document.getElementById('models-count').textContent = loaded.length + ' model' + (loaded.length !== 1 ? 's' : '') + ' loaded';

    // Available models tables (STT + TTS)
    const sttBody = document.getElementById('available-stt-body');
    const ttsBody = document.getElementById('available-tts-body');
    sttBody.innerHTML = '';
    ttsBody.innerHTML = '';

    const stt = models.filter(m => m.type === 'stt').sort((a,b) => {
      const order = {loaded:0,downloaded:1,available:2};
      return (order[a.state]||2) - (order[b.state]||2) || a.id.localeCompare(b.id);
    });
    const tts = models.filter(m => m.type === 'tts').sort((a,b) => {
      const order = {loaded:0,downloaded:1,available:2};
      return (order[a.state]||2) - (order[b.state]||2) || a.id.localeCompare(b.id);
    });

    function renderRow(m, tbody) {
      const tr = document.createElement('tr');
      tr.id = 'model-row-' + m.id.replace(/[^a-zA-Z0-9]/g, '_');
      const loading = _loadingModels.has(m.id);
      let action = '';
      if (loading) {
        action = `<span class="model-spinner"></span>Loading‚Ä¶`;
      } else if (m.state === 'loaded' && m.is_default) {
        action = `<button class="btn btn-sm" disabled style="opacity:0.4;cursor:not-allowed">Default</button>`;
      } else if (m.state === 'loaded') {
        action = `<button class="btn btn-danger btn-sm" onclick="unloadModel('${m.id}')">Unload</button>`;
      } else if (m.state === 'downloaded') {
        action = `<button class="btn btn-success btn-sm" onclick="loadModel('${m.id}')">Load</button>`;
      } else {
        action = `<button class="btn btn-sm" style="background:var(--accent);color:white;border-color:var(--accent)" onclick="loadModel('${m.id}')">Download &amp; Load</button>`;
      }
      tr.innerHTML = `<td><strong>${m.id}</strong></td><td>${m.provider||'‚Äî'}</td><td>${formatSize(m.size_mb)}</td><td style="font-size:0.8rem;color:var(--text2)">${m.description||'‚Äî'}</td><td>${stateBadge(m.state)}</td><td>${action}</td>`;
      tbody.appendChild(tr);
    }
    function stateBadge(s) { return statebage(s); }

    stt.forEach(m => renderAvailRow(m, sttBody));
    tts.forEach(m => renderAvailRow(m, ttsBody));

  } catch(e) { console.error('Failed to refresh models', e); }
  setTimeout(() => icon.classList.remove('spinning'), 500);
  if (!modelsInterval) modelsInterval = setInterval(refreshModels, 10000);
}

function renderAvailRow(m, tbody) {
  const tr = document.createElement('tr');
  const loading = _loadingModels.has(m.id);
  const providerProgress = _providerInstallProgress.get(m.id);
  let action = '';
  if (loading || m.state === 'downloading') {
    const progressText = providerProgress ? (providerProgress.output || providerProgress.error || 'Installing provider‚Ä¶') : (loading ? 'Working‚Ä¶' : 'Downloading‚Ä¶');
    const shortProgress = String(progressText).trim().split('\n').slice(-1)[0].slice(0, 80) || 'Working‚Ä¶';
    action = `<span class="model-spinner"></span><span style="font-size:0.8rem" title="${String(progressText).replace(/"/g,'&quot;')}">${shortProgress}</span>`;
  } else if (m.state === 'provider_missing') {
    action = `<button class="btn btn-sm" onclick="installProvider('${m.id}')">Install Provider</button>`;
  } else if (m.state === 'provider_installed') {
    action = `<div style="display:flex;gap:6px;flex-wrap:wrap"><button class="btn btn-sm" onclick="downloadModel('${m.id}')">Download</button><button class="btn btn-sm" onclick="loadModel('${m.id}')">Load</button></div>`;
  } else if (m.state === 'downloaded') {
    action = `<div style="display:flex;gap:6px;flex-wrap:wrap"><button class="btn btn-success btn-sm" onclick="loadModel('${m.id}')">Load</button><button class="btn btn-danger btn-sm" onclick="deleteModelArtifacts('${m.id}')">Delete</button></div>`;
  } else if (m.state === 'loaded' && m.is_default) {
    action = `<div style="display:flex;gap:6px;flex-wrap:wrap"><button class="btn btn-sm" disabled style="opacity:0.4;cursor:not-allowed">Default</button><button class="btn btn-danger btn-sm" onclick="deleteModelArtifacts('${m.id}')">Delete</button></div>`;
  } else if (m.state === 'loaded') {
    action = `<div style="display:flex;gap:6px;flex-wrap:wrap"><button class="btn btn-danger btn-sm" onclick="unloadModel('${m.id}')">Unload</button><button class="btn btn-danger btn-sm" onclick="deleteModelArtifacts('${m.id}')">Delete</button></div>`;
  } else {
    action = `<div style="display:flex;gap:6px;flex-wrap:wrap"><button class="btn btn-sm" onclick="downloadModel('${m.id}')">Download</button><button class="btn btn-sm" onclick="loadModel('${m.id}')">Load</button></div>`;
  }
  tr.innerHTML = `<td><strong>${m.id}</strong></td><td>${m.provider||'‚Äî'}</td><td>${formatSize(m.size_mb)}</td><td style="font-size:0.8rem;color:var(--text2)">${m.description||'‚Äî'}</td><td>${statebage(m.state)}</td><td>${action}</td>`;
  tbody.appendChild(tr);
}

function statebage(state) {
  const cls = {
    loaded:'badge-loaded', downloaded:'badge-downloaded', available:'badge-available',
    provider_missing:'badge-provider_missing', provider_installed:'badge-provider_installed', downloading:'badge-downloading'
  };
  const lbl = {
    loaded:'Loaded', downloaded:'Downloaded', available:'Available', provider_missing:'Provider Missing',
    provider_installed:'Provider Installed', downloading:'Downloading'
  };
  return `<span class="badge ${cls[state]||'badge-available'}">${lbl[state]||state}</span>`;
}

function parseApiError(err, fallback) {
  if (!err) return fallback;
  if (typeof err === 'string') return err;
  if (err.error) return parseApiError(err.error, fallback);
  if (err.message) return err.message;
  if (err.detail?.message) return err.detail.message;
  if (err.detail) return typeof err.detail === 'string' ? err.detail : JSON.stringify(err.detail);
  return fallback;
}

async function installProvider(id) {
  _loadingModels.add(id);
  _providerInstallProgress.set(id, {status:'installing', output:'Installing provider‚Ä¶', error:''});
  refreshModels();
  try {
    const r = await fetch('/api/providers/install', {method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({model:id})});
    const data = await r.json().catch(() => ({}));
    if (!r.ok) {
      toast(parseApiError(data, 'Provider install failed'), 'error');
      _loadingModels.delete(id);
      _providerInstallProgress.set(id, {status:'failed', output:'', error:parseApiError(data, 'Provider install failed')});
      refreshModels();
      return;
    }

    const jobId = data.job_id;
    if (!jobId) {
      toast('Provider install did not return a job id', 'error');
      _loadingModels.delete(id);
      _providerInstallProgress.set(id, {status:'failed', output:'', error:'Missing job id'});
      refreshModels();
      return;
    }

    if (_providerInstallPollers.has(id)) clearInterval(_providerInstallPollers.get(id));
    const poller = setInterval(async () => {
      try {
        const sr = await fetch(`/api/providers/install/${encodeURIComponent(jobId)}`);
        const status = await sr.json().catch(() => ({}));
        if (!sr.ok) {
          _providerInstallProgress.set(id, {status:'failed', output:'', error:parseApiError(status, 'Provider install failed')});
          clearInterval(poller); _providerInstallPollers.delete(id); _loadingModels.delete(id);
          toast(parseApiError(status, 'Provider install failed'), 'error');
          refreshModels();
          return;
        }

        _providerInstallProgress.set(id, status);
        refreshModels();

        if (status.status === 'done') {
          clearInterval(poller); _providerInstallPollers.delete(id); _loadingModels.delete(id);
          _providerInstallProgress.delete(id);
          toast(`Provider installed for ${id}`);
          await refreshModels();
        } else if (status.status === 'failed') {
          clearInterval(poller); _providerInstallPollers.delete(id); _loadingModels.delete(id);
          const err = status.error || 'Provider install failed';
          toast(err, 'error');
          refreshModels();
        }
      } catch (e) {
        clearInterval(poller); _providerInstallPollers.delete(id); _loadingModels.delete(id);
        _providerInstallProgress.set(id, {status:'failed', output:'', error:e.message});
        toast('Provider install failed: ' + e.message, 'error');
        refreshModels();
      }
    }, 2000);
    _providerInstallPollers.set(id, poller);
  } catch(e) {
    toast('Provider install failed: ' + e.message, 'error');
    _loadingModels.delete(id);
    _providerInstallProgress.set(id, {status:'failed', output:'', error:e.message});
    refreshModels();
  }
}

async function downloadModel(id) {
  _loadingModels.add(id); refreshModels();
  try {
    const r = await fetch(`/api/models/${encodeURIComponent(id)}/download`, {method:'POST'});
    const data = await r.json().catch(() => ({}));
    if (!r.ok) { toast(parseApiError(data, 'Download failed'), 'error'); return; }
    toast(`Model ${id} downloaded`);
  } catch(e) { toast('Failed to download model: ' + e.message, 'error'); }
  finally { _loadingModels.delete(id); refreshModels(); }
}

async function loadModel(id) {
  _loadingModels.add(id); refreshModels();
  try {
    const r = await fetch(`/api/models/${encodeURIComponent(id)}/load`, {method:'POST'});
    const data = await r.json().catch(() => ({}));
    if (!r.ok) { toast(parseApiError(data, 'Load failed'), 'error'); return; }
    toast(`Model ${id} loaded`);
  } catch(e) { toast('Failed to load model: ' + e.message, 'error'); }
  finally { _loadingModels.delete(id); refreshModels(); }
}

async function unloadModel(id) {
  try {
    const r = await fetch(`/api/models/${encodeURIComponent(id)}`, {method:'DELETE'});
    const data = await r.json().catch(() => ({}));
    if (!r.ok) { toast(parseApiError(data, `Failed to unload (HTTP ${r.status})`), 'error'); return; }
    toast(`Model ${id} unloaded`);
  } catch(e) { toast('Failed to unload model: ' + e.message, 'error'); }
  refreshModels();
}

async function deleteModelArtifacts(id) {
  if (!confirm(`Delete downloaded artifacts for ${id}?`)) return;
  _loadingModels.add(id); refreshModels();
  try {
    const r = await fetch(`/api/models/${encodeURIComponent(id)}/artifacts`, {method:'DELETE'});
    const data = await r.json().catch(() => ({}));
    if (!r.ok) { toast(parseApiError(data, 'Delete failed'), 'error'); return; }
    toast(data.status === 'deleted' ? `Deleted artifacts for ${id}` : `No artifacts found for ${id}`);
  } catch(e) { toast('Failed to delete artifacts: ' + e.message, 'error'); }
  finally { _loadingModels.delete(id); refreshModels(); }
}

async function loadPresets() {
  try {
    const r = await fetch('/api/voice-presets');
    const data = await r.json();
    const sel = document.getElementById('tts-preset');
    (data.presets || []).forEach(p => {
      const o = document.createElement('option');
      o.value = JSON.stringify(p);
      o.textContent = `${p.name} ‚Äî ${p.description || ''}`;
      sel.appendChild(o);
    });
  } catch(e) { console.error('Failed to load presets', e); }
}

function applyPreset() {
  const sel = document.getElementById('tts-preset');
  if (!sel.value) return;
  try {
    const p = JSON.parse(sel.value);
    if (p.voice) {
      const voiceSel = document.getElementById('tts-voice');
      // Try direct match first, then set blend
      const opt = Array.from(voiceSel.options).find(o => o.value === p.voice);
      if (opt) { voiceSel.value = p.voice; }
      if (p.voice.includes('+')) {
        document.getElementById('tts-blend').value = p.voice;
      }
    }
    if (p.speed) {
      document.getElementById('tts-speed').value = p.speed;
      document.getElementById('speed-val').textContent = p.speed;
    }
  } catch(e) { console.error('Failed to apply preset', e); }
}

/* ‚îÄ‚îÄ Init ‚îÄ‚îÄ */
loadSTTModels();
loadTTSModels().then(loadTTSCapabilities);
loadPresets();

// Fetch version from /health and update badge (Fix 8)
(async () => {
  try {
    const r = await fetch('/health');
    const data = await r.json();
    if (data.version) document.getElementById('version-badge').textContent = 'v' + data.version;
  } catch(e) { console.error('Failed to fetch version', e); }
})();
</script>
</body>
</html>
